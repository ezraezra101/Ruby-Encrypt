#!/usr/bin/env ruby

class String
  # colorization
  # borrowed from http://stackoverflow.com/questions/1489183/colorized-ruby-output
  def colorize(color_code)
    "\e[#{color_code}m#{self}\e[0m"
  end

  def red
    colorize(91) #or 31
  end

  def green
    colorize(32)
  end

  def yellow
    colorize(33)
  end

  def pink
    colorize(35)
  end

  def grey
    colorize(37)
  end
end




def rotate_13(input="hello world")
  decode= ''
  ascii=[]
  #converts to ascii
  input.each_byte do |c|
    ascii << c
  end

  for i in 0..ascii.length-1
    #Capital Letters
    if ascii[i]>=65 and ascii[i] <=90
      ascii[i]+=13
      if ascii[i]>90
        ascii[i] += -26
      end
    #lower case letters
    elsif ascii[i]>=97 and ascii[i]<=122
      ascii[i] +=13
      if ascii[i]>122
        ascii[i] += -26
      end
    end
    decode << ascii[i].chr
  end
  decode
end


def pi_encrypt(input='hello world', to_code=true,seed=0)
  source = 3.1415926535897932384626433
  decode= ''
  ascii=[]
  #This picks whether you are doing or undoing code
  case to_code
    when false
      to_code_coefficient= -1
    when true
      to_code_coefficient = 1
  end
  #converts to ascii
  input.each_byte do |c|
    ascii << c
  end

  #Encodes/decodes and converts back to text
  splitsource =source.to_s.split(%r{\s*}) - ['.']
  for i in 0..ascii.length-1
    ascii[i] += to_code_coefficient * splitsource[i+seed].to_i
    decode << ascii[i].chr
  end
  decode
end


class RSA_encrypt
  def make(e)
    primes=primegen()
    keys=self.keygen(e,primes)
    $n, $e= keys[1]
    $privatekey=keys[0]
    self.keysave(keys)
  end

  def primegen()
    #primes = [43,257,61,167]
    primes = [4801,1031,1999,167, 7919, 7643, 2017]
    #primes = [61,53,23]
    #primes = [11,13]
    primes
  end

  def keygen(e,primes)
    n=1
    totient=1
    d_set=[]

    #Failsafe: if the totient is not coprime with e, stuff breaks
    for i in 0..primes.length-1
      if (primes[i]-1)%e==0
        puts "Change the prime #{primes[i]} or e \(#{e}\)"
        x=1
      end
    end
    if x==1
      quit
    end

    for i in 0..primes.length-1
      n*=primes[i]
      totient*=primes[i]-1
    end
    i=0

    while (i*totient+1)%e != 0
      i+=1
    end
    d= (totient*i + 1)/e

    #Chinese remainder algorithim keygen
    for i in 0..primes.length-1
      d_set[i]=d% (primes[i]-1)
    end

      #computing the inverse modulus of q & p only 2 primes at the moment
    #i=0
    #while (i*primes[0]+1)%primes[1] != 0
    #  i+=1
    #end
    #qinv=(i*primes[0] + 1)/primes[1]

    #made to work with more primes
    primesinverse=[]
    primesproduct=1
    for i in 0..primes.length-1
      x=0
      while (x*primesproduct + 1) % primes[i] != 0
        x+=1
      end
      primesinverse[i]= (x*primesproduct + 1)/primes[i]
      primesproduct*=primes[i]
    end

    #privatekey=[n,d] - for when not using the Chinese remainder decryption
    privatekey=[primesinverse, d_set, primes]
    publickey=[n,e]
    output=[privatekey, publickey]
    output
  end

  def encrypt_once(input, n, e)
    output=(input**e)%n
    output
  end

  #def decrypt(input, n, d)
  #  output=(input**d)%n
  #end
  def decrypt_once(input,primesinverse,d_set,primes)
    #Chinese remainder decryption:
    m=[]
    for i in 0..primes.length-1
      m[i]=(input**d_set[i]) % primes[i]
    end
    #this part works with only two primes
    #h=(qinv*(m[0]-m[1]))%primes[0]
    #output= m[1] + h*primes[1]
    #fixed to make work with more primes
    primesproduct=1
    tempoutput=0

    for i in 0..primes.length-1
      temph=(primesinverse[i]*(tempoutput-m[i]))%primesproduct
      tempoutput=m[i] + temph*primes[i]
      primesproduct*=primes[i]
    end

    output=tempoutput

    output
  end
  def test(mesg=65,e=17)
    self.make(e)
    encrypted=self.encrypt_once(mesg,$n,$e)
    puts mesg
    puts "encrypted"
    puts encrypted
    puts "decrypted"
    puts self.decrypt_once(encrypted,$privatekey[0],$privatekey[1],$privatekey[2])
    #puts "This function is broken"
    puts "keys"
    puts $n
    puts $d
    puts $e
    puts "*********"
  end


  def keysave(keys)
    publickey= keys[1]
    privatekey=keys[0]
=begin
    puts "n, e"
    puts n, '\n', e
    puts 'privatekey'
    puts 'primesinverse'
    puts privatekey[0]
    puts 'd_set'
    puts privatekey[1]
    puts 'primes'
    puts privatekey[2]
=end

    private_key_file = File.new("rsa_private_key.rb", "w")

    private_key_file.write("def privatekey()\n"+self.private_key_string(privatekey)+"\nend\ndef publickey()\n"+self.public_key_string(publickey)+"\nend")

    private_key_file.close

    #public_key_file = File.new("rsa_public_key.txt")
  end
=begin
  myStr = "This is a test"
  aFile = File.new("myString.txt", "w")
  #<File:myString.txt>
  aFile.write(myStr)
  aFile.close
  aFile=File.open("myString.txt", "w")
=end
  def private_key_string(privatekey)
    private_key_names=["primesinverses","d_set", "primes"]
    private_key_string="privatekey=["
    for i in 0..privatekey.length-1
      private_key_string << private_key_names[i]+"=["
      for x in 0..privatekey[i].length-1
        private_key_string << privatekey[i][x].to_s+","
      end
      private_key_string << "],\n"
    end
    private_key_string << "]"
    private_key_string
  end
  def public_key_string(publickey)
    n, e= publickey
    public_key_string="publickey=[n="+n.to_s+",e="+e.to_s+"]"
  end



  def split_input(input,n=$n)
    max_l=self.max_length(n)
    #puts max_l
    split_input=[]
    for i in 0..(input.length()/max_l)
      split_input << input[max_l*i,max_l]
    end
    split_input
  end


  def max_length(n=$n)
    #returns the number of bytes encrypted in a single run
    i=0
    while 128**i<=n
      i+=1
    end
    max_length=i-1
  end

  def encrypt_splits(input,n=$n,e=$e)
    split=self.split_input(input,n)
    encrypted=[]
    for i in 0..split.length-1
      split_int=shrink_message(split[i])
      #Requires shrink_message
      encrypted << self.encrypt_once(split_int,n,e)
    end
    encrypted
  end
  def decrypt_splits(input,primesinverse=$privatekey[0],d_set=$privatekey[1],primes=$privatekey[2])
    decrypted=''
    for i in 0..input.length-1
      split_int=self.decrypt_once(input[i],primesinverse,d_set,primes)
      #Requires unshrink
      decrypted << unshrink(split_int)
    end
    decrypted
  end

end


def shrink_message(mesg)
  ascii=[]
  shrinked=0
  #converts to ascii
  mesg.each_byte do |c|
    ascii << c
  end
  #converts ascii into a integer, basically it concatinates what ascii is in base 128
  length=ascii.length
  for i in 1..length
    shrinked+=ascii[length-i]*128**(i-1)
  end
  shrinked
end

def shrink_mesg_1(mesg)
  #does not work properly
  ascii=[]
  shrinked=''
  #converts to ascii
  mesg.each_byte do |c|
    ascii << c
  end
  for i in 0..ascii.length-1
    byte_letter = ascii[i].to_s(2)
    if byte_letter.length < 7
      for x in 1..7-byte_letter.length
        byte_letter='0'+byte_letter
      end
    end
    shrinked << byte_letter

    #shrinked+=ascii[i]*128**(i)
  end
  shrinked.to_i(2)
end

def unshrink_mesg_1(mesg)
  #does not unshrink properly when the first character is less than 64ish
  decode=''
  ascii=[]
  mesg=mesg.to_s(2)
  for i in 0..mesg.length/7-1
    ascii << mesg[i*7,7].to_i(2)
    decode << ascii[i].chr
    #ascii[i]=mesg % (128**i)
    #mesg=(mesg-ascii[i])/128
    #decode << ascii[i].chr
  end
  decode
end

def unshrink(mesg)
  decode=''
  ascii=[]

  length=1
  while 128**length<=mesg
    length+=1
  end

  for i in 1..length
    ascii << mesg/(128**(length-i))
    mesg=mesg % (128**(length-i))
    decode << ascii[i-1].chr
  end

  decode
end

def rsa_keyload(key_file_path="rsa_private_key.rb")
  #require key_file_path
  load key_file_path
  $n, $e= publickey
  $privatekey=privatekey
  #puts $n, $e, $privatekey

end


#This should take user input
def run()
  STDOUT.flush
  puts 'Paste your message in here'
  input = gets.chomp
  puts 'Are you doing a rotate 13 cipher? Y/N'
  typeofencode=gets.chomp
  case typeofencode
  when 'Y', 'y', 'yes', 'Yes'
    to_code=13
    puts 'Here is your encrypted text:'
    puts rotate_13(input)
  else
    puts 'What is your seed? (0 for none)'
    seed=gets.chomp.to_i
    puts 'Are you decoding? Y/N'
    encoding=gets.chomp
    case encoding
    when 'Y', 'y', 'yes', 'Yes'
      to_code=true
    else
      to_code=false
    end
    puts 'Here is your encrypted text:'
    puts pi_encrypt(input,to_code,seed)
  end
  puts 'would you like to encode more? Y/N'
  again=gets.chomp
  case again
  when 'Y', 'y', 'yes', 'Yes'
    run()
  else
    puts 'Bye'
  end
end

def RSA_runtest()
  STDOUT.flush
  rsa=RSA_encrypt.new()
  puts "Load keys? Y/N"
  load=gets.chomp
  case load
  when 'Y', 'y', 'yes', 'Yes'
    rsa_keyload()
  else
    rsa.make(17)
  end
  

  max_length=rsa.max_length($n)
  puts "This encryption can only take about #{max_length} characters"

  puts "Input Message"
  mesg=gets.chomp
  mesg_int=shrink_message(mesg)
  puts "broken"
  encrypted=rsa.encrypt(mesg_int,$n,$e)
  #encrypted=rsa.encrypt_splits(mesg_int,$n,$e)
  puts "encrypted"
  puts encrypted
  #decrypted=rsa.decrypt(encrypted,$n,$d)
  puts "broken"
  decrypted=rsa.decrypt(encrypted,$privatekey[0],$privatekey[1],$privatekey[2])
  #decrypted=rsa.decrypt_splits(encrypted,$privatekey[0],$privatekey[1],$privatekey[2])
  puts "Decrypted integer"
  puts decrypted
  puts "Decrypted message"
  puts unshrink(decrypted)
  puts "again? Y/N"
  again=gets.chomp
  case again
  when 'Y', 'y', 'yes', 'Yes'
    RSA_runtest()
  else
    puts 'Bye'
  end
end


def test()
  begin
    raise "specialerror"
  rescue RuntimeError, "specialerror"
    puts "error".red
  rescue
    puts "Other Error"
  end
end

class RSA_test
  def intialize_rsa(rsa_name="rsa")
    @rsa_name=rsa_name
    @rsa_name=RSA_encrypt.new()
  end
  def rsa_name()
    @rsa_name
  end

  def keynil?()
    begin
      raise RuntimeError, "Keys_are_nil" if $n.nil? or $e.nil? or $privatekey.nil?
    rescue RuntimeError, "Keys_are_nil"
      puts "Encryption Keys are nil".red
      puts "$n="+$n.to_s
      puts "$e="+$e.to_s
      puts "privatekey jumble="+$privatekey
      true
    end
  end

  def keyclear()
    $n,$e,$privatekey=nil,nil,nil
  end

  def keyload(key_file_path="rsa_private_key.rb")
    begin
      rsa_keyload(key_file_path)
    rescue
      puts "error in loading".red
    else
      puts "Loaded keys".green
    ensure
      self.keynil?()
    end
  end

  def make(e=17)
    begin
      @rsa_name.make(e)
    rescue
      puts "error in making keys".red
    else
      puts "Made key".green
      #should add more?
    ensure
      self.keynil?()
    end
  end

  def shrinking(mesg=" Hello World ~|\"")
    begin
      shrunk = shrink_message(mesg)
      unshrunk = unshrink(shrunk)
      raise RuntimeError, "Shrinking unequal" if unshrunk!=mesg
    rescue RuntimeError, "Shrinking unequal"
      puts "Shrinking of message not working properly".red
      puts "Original message:#{mesg}\t".red
      puts "Unshrunk message:#{unshrunk}\t".red
    rescue
      puts "error in shrinking".red
    else
      puts "Shrinking working".green
    end
  end

  def encryption(mesg=" Hello World ~|\"")
    to_be_printed="\tInput Message:\t#{mesg}\n"
    begin
      max_length=@rsa_name.max_length($n)
    rescue
      puts "error in determining the number of characters encrypted at a time".red
    else
      to_be_printed << "\tThis encryption encrypts #{max_length} characters at a time\n"
      print ".".green
      $stdout.flush
    end
  
    #mesg_int=shrink_message(mesg)
    #puts "shrunk mesg\t"+ mesg_int.to_s
    #encrypted=rsa.encrypt(mesg_int,$n,$e)
    #encrypted=rsa.encrypt_splits(mesg_int,$n,$e)

    begin
      begin
        encrypted=@rsa_name.encrypt_splits(mesg,$n,$e)
      rescue
        puts "error in encryption".red
      else
        to_be_printed << "\tencrypted text:\t#{encrypted.to_s}\n"
        print ".".green
        $stdout.flush
      end

      begin
        decrypted=@rsa_name.decrypt_splits(encrypted,$privatekey[0],$privatekey[1],$privatekey[2])
      rescue
        puts "error in decryption".red
      else
        to_be_printed << "\tDecryption: #{decrypted}\n"
        print ".\n".green
        $stdout.flush
      end

      raise RuntimeError, "Decryption unequal" if decrypted!=mesg

    rescue RuntimeError, "Decryption unequal"
      puts "Decryption does not equal the input".red
    rescue
      puts "problem in encyption/decryption"
    else
      puts "Decryption equals encryption".green
    ensure
      puts to_be_printed.grey
    end

  end
end

def rsa_autotest(mesg="hello world test",load=false)
  rsatest=RSA_test.new()
  rsatest.intialize_rsa("rsa")
  rsatest.make()
  rsatest.keyclear()
  rsatest.keyload()
  rsatest.shrinking(mesg)
  rsatest.encryption(mesg)

  rsa=rsatest.rsa_name()

=begin
  puts "Load keys? Y/N"
  case load
  when true
    rsa_keyload()
    puts "keyloaded"
    again=false
  else
    rsa.make(17)
    again=true
  end

  begin
    rsa_keyload()
    raise RuntimeError, "Keys_are_nil" if $n.nil? or $e.nil? or $privatekey.nil?
  rescue RuntimeError, "Keys_are_nil"
    puts "Keys are nil".red
    puts "$n="+$n.to_s
    puts "$e="+$e.to_s
    puts "privatekey jumble="+$privatekey
  rescue
    puts "error in loading".red
  else
    puts "Loaded keys".green
  end

  max_length=rsa.max_length($n)
  puts "This encryption can only take about #{max_length} characters"

  puts "Input Message"
  puts mesg
  #mesg_int=shrink_message(mesg)
  #puts "shrunk mesg\t"+ mesg_int.to_s
  #encrypted=rsa.encrypt(mesg_int,$n,$e)
  #encrypted=rsa.encrypt_splits(mesg_int,$n,$e)
  encrypted=rsa.encrypt_splits(mesg,$n,$e)
  puts "encrypted\t"+encrypted.to_s


  decrypted=rsa.decrypt_splits(encrypted,$privatekey[0],$privatekey[1],$privatekey[2])
  #decrypted=rsa.decrypt_splits(encrypted,$privatekey[0],$privatekey[1],$privatekey[2])
  puts "Decrypted integer"
  puts decrypted
  #puts "Decrypted message"
  #puts unshrink(decrypted)
  if decrypted != mesg
    puts 'The decryption is different from the encryption'.red
  end
=end
end

rsa_autotest(" Hello W0rld TEST\\")

#RSA_runtest()
#run()

#For Hacking:
#decrypt(2790,[1,38],[53,49],[61,53])