#!/usr/bin/env ruby

def rotate_13(input="hello world")
  decode= ''
  ascii=[]
  #converts to ascii
  input.each_byte do |c|
    ascii << c
  end

  for i in 0..ascii.length-1
    #Capital Letters
    if ascii[i]>=65 and ascii[i] <=90
      ascii[i]+=13
      if ascii[i]>90
        ascii[i] += -26
      end
    #lower case letters
    elsif ascii[i]>=97 and ascii[i]<=122
      ascii[i] +=13
      if ascii[i]>122
        ascii[i] += -26
      end
    end
    decode << ascii[i].chr
  end
  decode
end


def pi_encrypt(input='hello world', to_code=true,seed=0)
  source = 3.1415926535897932384626433
  decode= ''
  ascii=[]
  #This picks whether you are doing or undoing code
  case to_code
    when false
      to_code_coefficient= -1
    when true
      to_code_coefficient = 1
  end
  #converts to ascii
  input.each_byte do |c|
    ascii << c
  end

  #Encodes/decodes and converts back to text
  splitsource =source.to_s.split(%r{\s*}) - ['.']
  for i in 0..ascii.length-1
    ascii[i] += to_code_coefficient * splitsource[i+seed].to_i
    decode << ascii[i].chr
  end
  decode
end


class RSA_encrypt
  def make(e)
    primes=primegen()
    keys=self.keygen(e,primes)
    $n, $e= keys[1]
    $privatekey=keys[0]
    self.keysave(keys)
  end

  def primegen()
    #primes = [43,257,61,167]
    #primes = [4801,1031,1999,167, 7919, 7643, 2017]
    #primes = [61,53,23]
    primes = [11,13]
    primes
  end

  def keygen(e,primes)
    n=1
    totient=1
    d_set=[]

    #Failsafe: if the totient is not coprime with e, stuff breaks
    for i in 0..primes.length-1
      if (primes[i]-1)%e==0
        puts "Change the prime #{primes[i]} or e \(#{e}\)"
        x=1
      end
    end
    if x==1
      quit
    end

    for i in 0..primes.length-1
      n*=primes[i]
      totient*=primes[i]-1
    end
    i=0

    while (i*totient+1)%e != 0
      i+=1
    end
    d= (totient*i + 1)/e

    #Chinese remainder algorithim keygen
    for i in 0..primes.length-1
      d_set[i]=d% (primes[i]-1)
    end

      #computing the inverse modulus of q & p only 2 primes at the moment
    #i=0
    #while (i*primes[0]+1)%primes[1] != 0
    #  i+=1
    #end
    #qinv=(i*primes[0] + 1)/primes[1]

    #made to work with more primes
    primesinverse=[]
    primesproduct=1
    for i in 0..primes.length-1
      x=0
      while (x*primesproduct + 1) % primes[i] != 0
        x+=1
      end
      primesinverse[i]= (x*primesproduct + 1)/primes[i]
      primesproduct*=primes[i]
    end

    #privatekey=[n,d] - for when not using the Chinese remainder decryption
    privatekey=[primesinverse, d_set, primes]
    publickey=[n,e]
    output=[privatekey, publickey]
    output
  end

  def encrypt(input, n, e)
    output=(input**e)%n
    output
  end

  #def decrypt(input, n, d)
  #  output=(input**d)%n
  #end
  def decrypt(input,primesinverse,d_set,primes)
    #Chinese remainder decryption:
    m=[]
    for i in 0..primes.length-1
      m[i]=(input**d_set[i]) % primes[i]
    end
    #this part works with only two primes
    #h=(qinv*(m[0]-m[1]))%primes[0]
    #output= m[1] + h*primes[1]
    #fixed to make work with more primes
    primesproduct=1
    tempoutput=0

    for i in 0..primes.length-1
      temph=(primesinverse[i]*(tempoutput-m[i]))%primesproduct
      tempoutput=m[i] + temph*primes[i]
      primesproduct*=primes[i]
    end

    output=tempoutput

    output
  end
  def test(mesg=65,e=17)
    self.make(e)
    encrypted=self.encrypt(mesg,$n,$e)
    puts mesg
    puts "encrypted"
    puts encrypted
    puts "decrypted"
    #puts self.decrypt(encrypted,$n,$d)
    puts "This function is broken"
    puts "keys"
    puts $n
    puts $d
    puts $e
    puts "*********"
  end


  def keysave(keys)
    publickey= keys[1]
    privatekey=keys[0]
=begin
    puts "n, e"
    puts n, '\n', e
    puts 'privatekey'
    puts 'primesinverse'
    puts privatekey[0]
    puts 'd_set'
    puts privatekey[1]
    puts 'primes'
    puts privatekey[2]
=end

    private_key_file = File.new("rsa_private_key.rb", "w")

    private_key_file.write("def privatekey()\n"+self.private_key_string(privatekey)+"\nend\ndef publickey()\n"+self.public_key_string(publickey)+"end")

    #private_key_file.close

    #public_key_file = File.new("rsa_public_key.txt")
  end
=begin
  myStr = "This is a test"
  aFile = File.new("myString.txt", "w")
  #<File:myString.txt>
  aFile.write(myStr)
  aFile.close
  aFile=File.open("myString.txt", "w")
=end
  def private_key_string(privatekey)
    private_key_names=["primesinverses","d_set", "primes"]
    private_key_string="privatekey=["
    for i in 0..privatekey.length-1
      private_key_string << private_key_names[i]+"=["+privatekey[i][0].to_s
      for x in 1..privatekey[0].length-1
        private_key_string << ","+privatekey[0][x].to_s
      end
      private_key_string << "],\n"
    end
    private_key_string << "]"
    private_key_string
  end
  def public_key_string(publickey)
    n, e= publickey
    public_key_string="publickey=[n="+n.to_s+",e="+e.to_s+"]"
  end
end

def shrink_message(mesg)
  ascii=[]
  shrinked=0
  #converts to ascii
  mesg.each_byte do |c|
    ascii << c
  end
  #converts ascii into a integer, basically it concatinates what ascii is in base 128
  length=ascii.length
  for i in 1..length
    shrinked+=ascii[length-i]*128**(i-1)
  end
  shrinked
end

def shrink_mesg_1(mesg)
  #does not work properly
  ascii=[]
  shrinked=''
  #converts to ascii
  mesg.each_byte do |c|
    ascii << c
  end
  for i in 0..ascii.length-1
    byte_letter = ascii[i].to_s(2)
    if byte_letter.length < 7
      for x in 1..7-byte_letter.length
        byte_letter='0'+byte_letter
      end
    end
    shrinked << byte_letter

    #shrinked+=ascii[i]*128**(i)
  end
  shrinked.to_i(2)
end

def unshrink_mesg_1(mesg)
  #does not unshrink properly when the first character is less than 64ish
  decode=''
  ascii=[]
  mesg=mesg.to_s(2)
  for i in 0..mesg.length/7-1
    ascii << mesg[i*7,7].to_i(2)
    decode << ascii[i].chr
    #ascii[i]=mesg % (128**i)
    #mesg=(mesg-ascii[i])/128
    #decode << ascii[i].chr
  end
  decode
end

def unshrink(mesg)
  decode=''
  ascii=[]

  length=1
  while 128**length<=mesg
    length+=1
  end

  for i in 1..length
    ascii << mesg/(128**(length-i))
    mesg=mesg % (128**(length-i))
    decode << ascii[i-1].chr
  end

  decode
end

def rsa_keyload(key_file_path="rsa_private_key.rb")
  #require key_file_path
  load key_file_path
  $n, $e= publickey
  $privatekey=privatekey

end


#This should take user input
def run()
  STDOUT.flush
  puts 'Paste your message in here'
  input = gets.chomp
  puts 'Are you doing a rotate 13 cipher? Y/N'
  typeofencode=gets.chomp
  case typeofencode
  when 'Y', 'y', 'yes', 'Yes'
    to_code=13
    puts 'Here is your encrypted text:'
    puts rotate_13(input)
  else
    puts 'What is your seed? (0 for none)'
    seed=gets.chomp.to_i
    puts 'Are you decoding? Y/N'
    encoding=gets.chomp
    case encoding
    when 'Y', 'y', 'yes', 'Yes'
      to_code=true
    else
      to_code=false
    end
    puts 'Here is your encrypted text:'
    puts pi_encrypt(input,to_code,seed)
  end
  puts 'would you like to encode more? Y/N'
  again=gets.chomp
  case again
  when 'Y', 'y', 'yes', 'Yes'
    run()
  else
    puts 'Bye'
  end
end

def RSA_runtest()
  STDOUT.flush
  rsa=RSA_encrypt.new()
  rsa.make(17)
  #rsa_keyload()

  i=0
  while 128**i<=$n
    i+=1
  end
  puts "This encryption can only take about #{i-1} characters"

  puts "Input Message"
  mesg=gets.chomp
  mesg_int=shrink_message(mesg)
  encrypted=rsa.encrypt(mesg_int,$n,$e)
  puts "encrypted"
  puts encrypted
  #decrypted=rsa.decrypt(encrypted,$n,$d)
  decrypted=rsa.decrypt(encrypted,$privatekey[0],$privatekey[1],$privatekey[2])
  puts "Decrypted integer"
  puts decrypted
  puts "Decrypted message"
  puts unshrink(decrypted)
  puts "again? Y/N"
  again=gets.chomp
  case again
  when 'Y', 'y', 'yes', 'Yes'
    RSA_runtest()
  else
    puts 'Bye'
  end
end

RSA_runtest()
#run()

#For Hacking:
#decrypt(2790,[1,38],[53,49],[61,53])