#!/usr/bin/env ruby
def encode(input='split test', to_code=true, seed=0)
  #input='split test'
  #seed = 0
  source = 3.1415926535897932384626433
  #to_code=true, false, or 13
  decode= ''
  ascii=[]

  #This picks whether you're doing or undoing code
  case to_code
  when false
      to_code_coefficient= -1
  when true
      to_code_coefficient = 1
  else
      to_code_coefficient=1
  end

  #Breaks the input string into pieces and converts to ascii
  splitcode=input.split(%r{\s*})

  input.each_byte do |c|
       ascii << c
  end


  #Actually converts to encoded ascii and then to text
  if to_code != 13
    splitsource =source.to_s.split(%r{\s*}) - ['.']
    for i in 0..ascii.length-1
      ascii[i] += to_code_coefficient * splitsource[i+seed].to_i
      decode << ascii[i].chr
    end
    #  if ascii[i]>126
     #     ascii[i] += -(126-31)
      #end
  # Ascii greater than 126 or less than 31 aren't characters


   #   if ( ascii[i] >=  65 and ascii[i] <= 65+25 ) or ( ascii[i] >=  97 and ascii[i] <= 97+25 )



    #  else
    #      puts 'fail'
   #   end

  #13 shift
  else
    for i in 0..ascii.length-1       
      if ascii[i]>=65 and ascii[i] <=90
        ascii[i]+=13
        if ascii[i]>90
          ascii[i] += -26
        end
      elsif ascii[i]>=97 and ascii[i]<=122
        ascii[i] +=13
        if ascii[i]>122
          ascii[i] += -26
        end
      end
      decode << ascii[i].chr
    end
  end
  decode
end
#puts encode('Hi', true, 0)

 #puts decode

#This should take user input
def run()
  STDOUT.flush
  puts 'Paste your message in here'
  input = gets.chomp
  puts 'Are you doing a rotate 13 cipher? Y/N'
  typeofencode=gets.chomp
  case typeofencode
  when 'Y', 'y', 'yes', 'Yes'
    to_code=13
  else
    puts 'What is your seed? (0 for none)'
    seed=gets.chomp.to_i
    puts 'Are you decoding? Y/N'
    encoding=gets.chomp
    case encoding
    when 'Y', 'y', 'yes', 'Yes'
      to_code=true
    else
      to_code=false
    end
  end
  puts 'Here is your encrypted text:'
  puts encode(input,to_code,seed)
  puts 'would you like to encode more? Y/N'
  again=gets.chomp
  case again
  when 'Y', 'y', 'yes', 'Yes'
    run()
  else
    puts 'Bye'
  end
end

#Section for RSA encryption:
#Note: Variables are all named not according to convention
#This is really insecure. I'm also putting it online . . . Why am I using it for encryption?

#Resources:
#http://mathcircle.berkeley.edu/BMC3/rsa/node4.html
#http://www.javamex.com/tutorials/cryptography/rsa_encryption.shtml
#http://en.wikipedia.org/wiki/RSA_%28algorithm%29#Decryption
#For the decrypting raising to a power: http://en.wikipedia.org/wiki/Square-and-multiply_algorithm
#Prime #s: http://www.bigprimes.net/archive/prime/8/
$pubkey=1
def rsa_private_keygen()
  $privatekey = [5279,6133]
end
def rsa_pub_keygen()
  for i in 0..$privatekey.length-1
    $pubkey*=$privatekey[i]
  end
end
def to_rsa(input, pubkey, e)
  output=(input**e)%pubkey
  output
end


#gcdext and invert are borrowed from https://gist.github.com/2388745
#Ruby modular arithmatic
  def gcdext(x, y)
    if x < 0
      g, a, b = gcdext(-x, y)
      return [g, -a, b]
    end
    if y < 0
      g, a, b = gcdext(x, -y)
      return [g, a, -b]
    end
    r0, r1 = x, y
    a0 = b1 = 1
    a1 = b0 = 0
    until r1.zero?
      q = r0 / r1
      r0, r1 = r1, r0 - q*r1
      a0, a1 = a1, a0 - q*a1
      b0, b1 = b1, b0 - q*b1
    end
    [r0, a0, b0]
  end
  
  # Returns the inverse of `num` modulo `mod`.
  #
  # @param [Integer] num the number
  # @param [Integer] mod the modulus
  # @return [Integer]
  # @raise ZeroDivisionError if the inverse of `base` does not exist
  def invert(num, mod)
    g, a, b = gcdext(num, mod)
    unless g == 1
      raise ZeroDivisionError.new("#{num} has no inverse modulo #{mod}")
    end
    a % mod
  end






def from_rsa(input,p,q, e)
  #(e*d=1 )% ((p-1)*(q-1))

  #Notworking example of finding d

  #e*d = 1 (mod totient)
  #if e==3 and totient==11
  # 3*d= 1 (mod 11)
  #Since 3*4 == 12 (mod 11) ==1
  # d can equal 4
  #http://en.wikipedia.org/wiki/Modular_multiplicative_inverse


  i=1
  #(p-1)*(q-1) is called Euler's totient function, it gives the number of integers that are coprime (share no factors) of a positive number
  #de=i*((p-1)*(q-1))+1
  totient=(p-1)*(q-1)
  #doesn't work: d**(totient-1)=d**-1    (mod pq)
  d=(1/e)%totient
  #d= (totient*i + 1)/e
  #d=invert(e,totient)
  #d=de/e
  puts (input**d)% $pubkey
  puts d
end

rsa_private_keygen()
rsa_pub_keygen()
mesg=to_rsa(8,$pubkey,7)
puts "mesg"
puts mesg
puts "From_rsa"
from_rsa(mesg,61,53,7)
puts "keys"
puts $privatekey
puts $pubkey
  #This section hopes to compute pi however much I wish
  #a resource I could look at is http://rubyquiz.strd6.com/quizzes/202-digits-of-pi
  #pi= (4.0/(8*k+1)-2.0/(8*k+4)-1.0/(8*k+5)-1.0/(8*k+6)) / (16**k)

  #Pi = SUMk=0 to infinity 16-k [ 4/(8k+1) - 2/(8k+4) - 1/(8k+5) - 1/(8k+6) ].
  #ruby info:
  #http://www.ruby-lang.org/en/libraries/


 # run()



#Will's gui code:
Shoes.app :width=>400, :height=>340 do
  flow do
    @e=edit_line
    button "Go!" do
      @abc.text = encode(@e.text,13)
    end
    @abc=edit_line
  end
end

