{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf510
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww7280\viewh10140\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs24 \cf0 def encode (input='split test', to_code=true, seed=0)\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li480\pardirnatural
\cf0 #input='split test'\
#seed = 0\
source = 3.1415926535897932384626433\
#to_code=true\
\
decode= ''\
ascii=[]\
\
#This picks whether you're doing or undoing code\
if to_code == false\
    to_code_coefficient= -1\
else\
    to_code_coefficient=1\
end\
\
#Breaks the input string into pieces and converts to ascii\
splitcode=input.split(%r\{\\s*\})\
\
input.each_byte do |c|\
     ascii << c\
end\
\
\
#Actually converts to encoded ascii and then to text\
\
splitsource =source.to_s.split(%r\{\\s*\}) - ['.']\
for i in 0..ascii.length-1\
    ascii[i] += to_code_coefficient * splitsource[i+seed].to_i\
\
  #  if ascii[i]>126\
   #     ascii[i] += -(126-31)\
    #end\
# Ascii greater than 126 or less than 31 aren't characters\
\
\
 #   if ( ascii[i] >=  65 and ascii[i] <= 65+25 ) or ( ascii[i] >=  97 and ascii[i] <= 97+25 )\
\
        decode << ascii[i].chr\
\
  #  else\
  #      puts 'fail'\
 #   end\
     \
end\
decode\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
end\
puts encode('Hi', 0, true)\
\
#puts decode\
\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li480\pardirnatural
\cf0 #This should take user input\
#STDOUT.flush\
#to_code = gets.chomp\
\
\
pi= (4.0/(8*k+1)-2.0/(8*k+4)-1.0/(8*k+5)-1.0/(8*k+6)) / (16**k)\
\
\pard\pardeftab720

\f1 \cf0 #Pi = SUM
\fs20 \sub k=0 to infinity
\fs24 \nosupersub  16
\fs20 \super -k
\fs24 \nosupersub  [ 4/(8k+1) - 2/(8k+4) - 1/(8k+5) - 1/(8k+6) ].}